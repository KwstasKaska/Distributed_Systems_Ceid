Άσκηση 1

Ξέρουμε ότι η πολυπλοκότητα επικοινωνίας παριστά τον αριθμό των μη-μηδενικών μηνυμάτων που στέλνεται μέχρι να εκλεχθεί ο αριθμός.
Για την πολυπλοκότητα της επικοινωνίας ισχύει:
Α)best case: εάν οι διεργασίες διαταχθούν σε αύξουσα σειρά UIDs, τότε η πολυπλοκότητα επικοινωνίας μπορεί να μειωθεί από Ο(n^2) σε O(n)


Οι κόμβοι συμβολίζουν τα UIDs. 
Πρώτος Γύρος: Συνολικό πλήθος μη-μηδενικών μηνυμάτων = 5..n
Δεύτερος Γύρος: Συνολικό πλήθος μη-μηδενικών μηνυμάτων = 1
Τρίτος Γύρος: Συνολικό πλήθος μη-μηδενικών μηνυμάτων = 1
Τέταρτος Γύρος: Συνολικό πλήθος μη-μηδενικών μηνυμάτων = 1
Πέμπτος Γύρος: Συνολικό πλήθος μη-μηδενικών μηνυμάτων = 1
Άθροισμα μηνυμάτων: 1 + 1 + 1 + 1 + .. + n = O(n)

Β) Worst case O(n^2): επιτυγχάνεται εάν παρατάξουμε τις διεργασίες με φθίνουσα σειρά


Οι κόμβοι συμβολίζουν τα UIDs. 
Πρώτος Γύρος: Συνολικό πλήθος μη-μηδενικών μηνυμάτων = 5..n
Δεύτερος Γύρος: Συνολικό πλήθος μη-μηδενικών μηνυμάτων = 4
Τρίτος Γύρος: Συνολικό πλήθος μη-μηδενικών μηνυμάτων = 3
Τέταρτος Γύρος: Συνολικό πλήθος μη-μηδενικών μηνυμάτων = 2
Πέμπτος Γύρος: Συνολικό πλήθος μη-μηδενικών μηνυμάτων = 1
Άθροισμα μηνυμάτων: 1 + 2 + 3 + 4 + .. + n = n/2[2+(n-1)] = n+[n(n-1)]/2 = O(n^2) 

Άσκηση 2

Κόμβοι δακτυλίου: -12-3-6-10-14-11-8-7-15-4-17-5-2-9-1-


Κόμβοι   Φάση 0	Φάση 1	Φάση 2	Φάση 3	Φάση 4
 12	      4	      8	      12	    0	      0
 3	       2	      0      	0	     0     	 0
 6	       3	      0	      0	     0      	0
 10	      3	      0	      0	     0	      0
 14	      4     	 8	     12	     0	      0
 11	      3	      0	      0	     0	      0
 8	       3	      0	      0	     0	      0
 7	       2	      0     	 0     	0	      0
 15	      4	      6	      0	     0	      0
 4	       2	      0	      0	     0	      0
 17	      4	      8	      16	    32	    30
 5	       3	      0	      0	     0	      0
 2	       2	      0	      0     	0     	 0
 9	       4	      6	      0     	0	      0
 1	       2	      0	      0	     0      	0
Σύνολο	  45     	36	      40	    32	    30



Το πλήθος των μηνυμάτων του αλγορίθμου θα ελαχιστοποιούταν αν, μετα τη φάση 0, παρέμενε awake μόνο η διεργασία με το μεγαλύτερο UID. Ένας τρόπος ανάθεσης θα ήταν ο εξής:



Κόμβοι δακτυλίου: -5-6-7-8-9-10-11-12-14-15-17-1-2-3-4-


Άσκηση 3

Επεξήγηση αλγορίθμου
Κάθε κόμβος στέλνει στον δεξιόστροφο γείτονά του ένα μήνυμα που περιέχει το UID του. Ταυτόχρονα έχει ένα μετρητή με αρχική τιμή 1. Ο κόμβος που λαμβάνει αυτό το μήνυμα το συγκίνει με το δικό του UID και αν είναι διαφορετικό ο μετρητής αυξανεται κατά 1 και προωθείται το UID του στον δεξιόστροφο γείτονά του. Αν το UID είναι ίδιο με το δικό του τότε ο μετρητής ισούται με το συνολικό πλήθος διεργασιών n.
Ψευδοκώδικας
Το αλφάβητο των μηνυμάτων n είναι το σύνολο των UIDs.
•	States (i): 
y, ένα UID, αρχικά το UID της i
counter, ένας ακέραιος, αρχικά 1
z, ένα UID ή NULL, αρχικά το UID της i
x, ένας ακέραιος, αρχικά 0
•	msgs (i):
στείλε την τιμή του z στον δεξιόστροφο γείτονα
•	trans (i):
if in_nbrs(i+1) is u, ένα UID, then 
if u != y   then   z  u, counter  counter + 1
else xcounter, z=NULL

Για την ορθότητα του αλγορίθμου αρκεί να δείξουμε ότι ο counter στο τέλος του αλγορίθμου θα έχει μετρήσει ακριβώς τις διεργασίες του αλγορίθμου. Αυτό ισχύει καθώς ο counter έχει αρχική τιμή 1 και αυξάνεται κατά 1 κάθε φορά που μία διεργασία παίρνει ένα διαφορετικό UID από τη δικιά της. Ταυτόχρονα επειδή έχουμε κατευθυνόμενο δακτύλιο και οι διεργασίες κινούνται δεξιόστροφα κάθε UID περνάει ακριβώς μια φορά από κάθε διεργασία, τερματίζοντας στην διεργασία από όπου ξεκίνησε. Άρα ο counter θα μετρήσει το ακριβές και συνολικό πλήθος διεργασιών n.

Η χρονική πολυπλοκότητα είναι Ο(n) καθώς ο counter μετράει τον συνολικό αριθμό των γύρων που εκτελούνται.
Η πολυπλοκότητα κοινωνίας ειναι Ο(n^2) καθώς κάθε γύρο κάθε διεργασία στέλνει ακριβώς ένα μήνυμα.


Άσκηση 4

Βάση Επαγωγής
Για r=1 έχουμε ότι d=1 άρα κάθε διεργασία με απόσταση d=1 από τη ρίζα έχει ορίσει τον γονέα της, ο οποίος βρίσκεται σε απόσταση 0 από τη ρίζα. Που ισχύει.
Επαγωγική υπόθεση
Έστω ότι στον γύρο r ισχύει ο synchBFS.
Επαγωγικό βήμα
Αρκεί να δείξω ότι ισχυεί για τον γύρο r+1, όπου κάθε διεργασία σε απόσταση 1<=d<=r από τη ρίζα έχει ορίσει τον γονέα της, ο οποίος βρίσκεται σε απόσταση d-1 από τη ρίζα. Αυτό ισχύει από την επαγωγική υπόθεση και πλεόν πρέπει να αποδείξω για διεργασίες με απόσταση ακριβώς r+1 από τη ρίζα. Οι διεργασίες αυτές έχουν τουλάχιστον ένα γείτονα σε απόσταση r από τη ρίζα. Επομένως από επαγωγική υπόθεση κάθε τέτοια διεργασία μετά από r γύρους θα έχει ορίσει τον γονέα της. Άρα στο r+1 γύρο κάθε γειτονική διεργασία σε απόσταση r από τη ρίζα θα στείλει μήνυμα αναζήτησης στους γείτονες της, επομένως οι γειτονικές διεργασίες θα ορίσουν ως γονέα μία από τις διεργασίες που βρίσκονται σε απόσταση d-1 από τη ρίζα.

Άσκηση 5
Επεξήγηση Αλγορίθμου:
Η διεργασία u ξεκινάει έναν αλγόριθμο SynchBFS με ρίζα τον εαυτό της.Ξεκινώντας από τα φύλλα κάθε κόμβος στέλνει στον γονέα της τον αριθμό number(i) , ο γονέας προσθέτει τις τιμές αυτές με την δικιά του και με τη σειρά του στέλνει το άθροισμα αυτό στο δικό του γονέα.Μόλις φτάσει στην ρίζα θα έχουμε το συνολικό άθροισμα και γνωρίζοντας τον αριθμό των διεργασιών ο κομβος u  θα το διαιρέσει με το σύνολο , n, των κόμβων.

Ψευδοκώδικας
Το αλφάβητο των μηνυμάτων M αποτελείται από το σύνολο των UIDs και συνολο των  number(i) των κόμβων που είναι  φυσικοί αριθμοί και το μήνυμα ACK.
•	states(i):

u, ένα UID, αρχικά το UID u(i) της i.

parent, ένα UID, αρχικα NULL.Aν i=a (η ρίζα) τότε αρχικά, parent<-NULL. 

q, boolean, αρχικα false. Αν  i=a(η ρίζα) τότε αρχικά, q<-true //Ένας μαρκαρισμένος κόμβος.

w, boolean, αρχικά false. Αν i=a(η ρίζα) τότε αρχικά, w<-true //Ένας κόμβος που μόλις μαρκαρίστηκε.

wait_ack, boole an, αρχικά false   //Καθορίζει αν ενας κόμβος είναι φύλλο ή όχι.

x(i), ενας φυσικός αριθμός   //δοσμένος πριν την εναρξη του αλγορίθμου.

sum, ενας πραγματικός αριθμός, αρχικά x(i).

x, ενας πραγματικός αριθμός   //η έξοδος του αλγορίθμου.

y, ένα UID ή null, αρχικά NULL.Αν i=a τότε, αρχικά, y <- a.

mode ε {0,1,2}, αρχικά 0   //Το 0 καθορίζει την δημιουργία του δέντρου, το 1 καθορίζει το άθροισμα των τιμών των κόμβων, το 2 καθορίζει την διαδικασία των φύλλων αποστολής των τιμών τους.

•	msgs(i):

if mode =0 and w= true then 
 στείλε το y σε κάθε γείτονα 
 στείλε ACK στον parent
else if mode=2 στείλε το sum στον parent.

•	trans(i):

if mode=2 then mode<-1 



else if mode = 0
   if wait_ack=true then   wait_ack=false
        if το συνολο των εισερχόμενων μηνυμάτων δεν περιεχει το ACK then mode<-2
       endif 
   endif
  if w=true then w<- false, wait_ack<-true
  endif

y<-null

if q=false and το συνολο των εισερχόμενων μηνυμάτων είναι A, ένα υποσύνολο UIDs, then 
           επίλεξε τυχαία ένα aεΑ και θέσε parent=a
           q<-true
           w<-true
           y<-a
endif
                 if q=true and το συνολο των εισερχόμενων μηνυμάτων είναι Κ, ένα μη κενό υποσύνολο φυσικών αριθμών, then 
                           mode<-2
                           sum<-sum+x(i)
                            if i=a then x=sum/n endif //οπου n το σύνολο των διεργασιών 
                   endif
    endif               

Χρονική πολυπλοκότητα : Ο(diam) .Καθώς ο αλγόριθμος απαιτεί diam γύρους .

Πολυπλοκότητα επικοινωνίας : Ο(m) οπου m είναι το πλήθος των πλευρών .
